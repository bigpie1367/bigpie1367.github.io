<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>no_intellectual.log</title>
    <link>https://bigpie1367.github.io/</link>
    
    <atom:link href="https://bigpie1367.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>지적이지 못한 개발자의 로그</description>
    <pubDate>Tue, 16 Jan 2024 07:16:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>NCP + MS SQL in macOS</title>
      <link>https://bigpie1367.github.io/2024/01/16/NCP-MS-SQL-in-macOS/</link>
      <guid>https://bigpie1367.github.io/2024/01/16/NCP-MS-SQL-in-macOS/</guid>
      <pubDate>Tue, 16 Jan 2024 04:15:18 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h1&gt;&lt;p&gt;최근 회사 업무로 인해 네이버 클라우드 플랫폼(이하 NCP)에 MS SQL DB를 구축해야 할 일이 생겼다. 이에 자료를 찾아보니 Window 환경에서 MS SQL을 구축하는 정보들은 다수 존재하나 macOS 환경에서 구축하는 글은 드물어 관련 경험을 기록하고자 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h1 id=&quot;본론&quot;&gt;&lt;a href=&quot;#본론&quot; class=&quot;headerlink&quot; title=&quot;본론&quot;&gt;&lt;/a&gt;본론&lt;/h1&gt;&lt;h2 id=&quot;NCP-설정&quot;&gt;&lt;a href=&quot;#NCP-설정&quot; class=&quot;headerlink&quot; title=&quot;NCP 설정&quot;&gt;&lt;/a&gt;NCP 설정&lt;/h2&gt;&lt;p&gt;기본적으로 MS SQL을 NCP에서 호스팅하기 위해선 2가지 방법이 존재한다. &lt;/p&gt;
&lt;h3 id=&quot;Cloud-DB-for-mssql&quot;&gt;&lt;a href=&quot;#Cloud-DB-for-mssql&quot; class=&quot;headerlink&quot; title=&quot;Cloud DB for mssql&quot;&gt;&lt;/a&gt;Cloud DB for mssql&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MSSQL을 위한 DBMS 및 각종 툴들이 설치된 상태&lt;/li&gt;
&lt;li&gt;별도의 데이터베이스 설정 없이 웹상에서 바로 모니터링 및 이용 가능&lt;/li&gt;
&lt;li&gt;스탠다드 기준 한달 62만원 정도의 비용 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Basic-Server&quot;&gt;&lt;a href=&quot;#Basic-Server&quot; class=&quot;headerlink&quot; title=&quot;Basic Server&quot;&gt;&lt;/a&gt;Basic Server&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;기본 Linux 서버로, MSSQL을 호스팅하기위한 별도의 설정이 필요함&lt;/li&gt;
&lt;li&gt;Ubuntu 18.04 환경&lt;/li&gt;
&lt;li&gt;스탠다드 기준 한달 7만원 정도의 비용 발생&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>최근 회사 업무로 인해 네이버 클라우드 플랫폼(이하 NCP)에 MS SQL DB를 구축해야 할 일이 생겼다. 이에 자료를 찾아보니 Window 환경에서 MS SQL을 구축하는 정보들은 다수 존재하나 macOS 환경에서 구축하는 글은 드물어 관련 경험을 기록하고자 한다.</p><p>&nbsp;</p><h1 id="본론"><a href="#본론" class="headerlink" title="본론"></a>본론</h1><h2 id="NCP-설정"><a href="#NCP-설정" class="headerlink" title="NCP 설정"></a>NCP 설정</h2><p>기본적으로 MS SQL을 NCP에서 호스팅하기 위해선 2가지 방법이 존재한다. </p><h3 id="Cloud-DB-for-mssql"><a href="#Cloud-DB-for-mssql" class="headerlink" title="Cloud DB for mssql"></a>Cloud DB for mssql</h3><ul><li>MSSQL을 위한 DBMS 및 각종 툴들이 설치된 상태</li><li>별도의 데이터베이스 설정 없이 웹상에서 바로 모니터링 및 이용 가능</li><li>스탠다드 기준 한달 62만원 정도의 비용 발생</li></ul><h3 id="Basic-Server"><a href="#Basic-Server" class="headerlink" title="Basic Server"></a>Basic Server</h3><ul><li>기본 Linux 서버로, MSSQL을 호스팅하기위한 별도의 설정이 필요함</li><li>Ubuntu 18.04 환경</li><li>스탠다드 기준 한달 7만원 정도의 비용 발생</li></ul><p><del>해당 데이터베이스 서버를 단순 데이터 수신으로만 사용할 예정이므로 Basic Server에 Mssql Docker를 띄운 상태로 테스트를 진행할 예정이다.</del></p><p>기존에는 비용적인 측면에서 NCP에서 1년간 무료로 제공하는 Micro Server를 통해 MS SQL을 호스팅하려 하였으나, 네이버 클라우드에서 무료로 제공하는 Micro Server의 경우 메모리 1GB를 제공하는 반면 MS SQL을 서비스하기 위해선 최소 2GB의 메모리를 필요로 한다. 따라서 Micro Server가 아닌 Standard Server를 기준으로 테스트를 진행하고자 한다.</p><img width="1481" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1 12 42" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/669f5ec2-ccc3-4a1d-b80a-e55d4d9a56cd"><center>클라우드 서버에서 사용할 OS</center><p>&nbsp;</p><img width="994" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10 55 26" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/4d243049-b5d2-4b11-8e8d-e75b3fb25462"><center>클라우드 서버 상세 정보</center><p>&nbsp;</p><img width="1503" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4 13 51" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/a56631ac-d0c9-450b-832a-248cee0aa14a"><center>최종 생성된 클라우드 서버</center><p>&nbsp;</p><p>추가로 본 글에서는 macOS 터미널을 통해 해당 클라우드 서버에 접속할 예정이다. NCP는 <code>SSH</code> 접속을 위한 <code>22</code>번 포트를 외부에서 접근하는 것을 허용하지 않아 포트 포워딩을 해주어야 한다.</p><img width="1506" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4 13 51 복사본" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/ea02819b-1083-46e9-8a35-6ce4afb242a2"><center>포트 포워딩 설정</center><p>&nbsp;</p><img width="992" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10 38 09" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/470d5181-9efe-4128-b102-fe383cc74040"><center>`22`번 포트(내부)를 `20001`번 포트(외부)로 포워딩</center><p>&nbsp;</p><p>이후 <code>20001</code>번 포트를 외부 IP에서 접근할 수 있도록 ACG에서 허용해주어야 한다. ACG는 일종의 방화벽으로, NCP에서 제공하는 IP 기반 필터링 기능이다. 본 글에서는 추가로 이후의 DB 접근을 위한 <code>20002</code>번 포트를 개방해주었다.</p><img width="1494" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4 14 33" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/3edc2a77-ae17-4213-bd45-b2bcc45798e1"><center>ACG 설정 페이지</center><p>&nbsp;</p><img width="1494" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10 37 22" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/73696fec-c5b2-49fa-8e2a-1c1af1229a34"><center>`20001` & `20002`번 포트를 외부에서 접근할 수 있도록 허용</center><p>&nbsp;</p><p>SSH만을 이용해 해당 서버에 접근하여 이용할 경우는 <code>서버 접속용 공인 IP</code>를 통해 접근해 이용하면 되지만, 외부에서 SSH가 아닌 DB에 직접 접근할 경우 <code>공인 IP</code> 할당을 필요로 한다. 다만 <code>공인 IP</code>의 경우 추가로 비용이 발생하니 유의할 필요가 있다. 발급받고 부여하는 과정은 간단해 최종 이미지만 첨부하도록 하겠다.</p><img width="1223" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12 41 29" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/2b891d36-c23a-4913-99b0-bd816ec316ee"><center>공인 IP 비용</center><p>&nbsp;</p><img width="1482" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11 13 49" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/c869c0e6-5125-457a-a92f-36e055835af6"><center>공인 IP 할당을 완료한 모습</center><p>&nbsp;</p><h2 id="MSSQL-설치"><a href="#MSSQL-설치" class="headerlink" title="MSSQL 설치"></a>MSSQL 설치</h2><p>상기 과정을 통해 NCP 설정을 완료하였다면 이제 해당 서버로 접근할 수 있다. 접근을 위한 명령어는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SSH를 통한 서버 내 접근</span></span><br><span class="line">ssh root@&lt;서버 접속용 공인 IP&gt; -p &lt;포워딩한 포트&gt;</span><br></pre></td></tr></table></figure><p>최초 접근할 경우 패스워드를 필요로 하는데, 초기 패스워드는 콘솔에서 서버 생성시 활용한 인증키를 통해 확인할 수 있다.</p><img width="1504" alt="스크린샷 2024-01-16 오후 1 48 41" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/e6afdfa4-10c1-415b-93a5-480d60598810"><center>초기 관리자 비밀번호 확인</center><p>&nbsp;</p><img width="495" alt="스크린샷 2024-01-16 오후 1 49 02" style="margin-left: auto; margin-right: auto; display: block;" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/edc0a9d7-6c88-4069-9788-d06a6a86c988"><center>초기 관리자 비밀번호 확인</center><p>&nbsp;</p><p>이후 서버에 접근한 뒤 MS SQL 서버를 호스팅하기 위한 도커 &amp; 도커 컴포즈를 아래 명령어를 통해 설치할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Docker 설치를 위한 명령어</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 시스템 업데이트</span></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필수 패키지 설치</span></span><br><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker repository key 추가</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker repository 추가</span></span><br><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 시스템 업데이트</span></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 설치</span></span><br><span class="line">sudo apt install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 권한 허용</span></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 실행 확인</span></span><br><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Docker-Compose 설치를 위한 명령어</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker-Compose 설치</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker-Compose 권한 허용</span></span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>이후 MS SQL Docker를 위해 아래와 같이 <code>docker-compose.yml</code> 파일을 작성하였다. 해당 파일은 <code>2019-latest</code> 이미지를 활용하여 MS SQL Docker Container를 생성한다. 또한 데이터 처리를 도울 스크립트들과 데이터 보존을 위해 디렉토리들을 추가로 바운딩하였다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">sqlserver:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">mcr.microsoft.com/mssql/server:2019-latest</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">mssql_service</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">mssql</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">20002</span><span class="string">:1433</span></span><br><span class="line">        <span class="attr">expose:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;20002&quot;</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./../sql1data:/var/opt/mssql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./:/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">ACCEPT_EULA:</span> <span class="string">Y</span></span><br><span class="line">        <span class="attr">SA_PASSWORD:</span> <span class="string">YOUR_OWN_PASSWORD</span></span><br></pre></td></tr></table></figure><p>이후 작성한 <code>docker-compose.yml</code> 파일을 통해 MSSQL Docker Container를 동작시킨 뒤 접속하였다. 해당 과정을 스크립트를 통해 자동화하였다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># restart_docker.sh</span></span><br><span class="line">docker-compose -p incoroutine down</span><br><span class="line">docker-compose -p incoroutine up -d</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Docker 활성화</span></span><br><span class="line">sh restart_docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dokcer 내부 접속</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mssql_service /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># MSSQL 접속</span></span><br><span class="line">/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P YOUR_OWN_PASSWORD</span><br></pre></td></tr></table></figure><img width="1026" alt="스크린샷 2024-01-16 오전 10 46 44" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/bf6091d3-ac23-48bc-a373-81b57661c3d7"><center>MS SQL 접근에 성공할 경우 터미널 화면</center><p>&nbsp;</p><p>MS SQL에 정상적으로 접근됨을 확인하였으니 테이블을 생성해보자. 다만 필자는 MS SQL 문법을 다루는데 미숙함이 있어 해당 과정 또한 스크립트를 통해 자동화하였다. 아래 코드의 경우 테이블 정보를 비롯한 내용들은 본인의 필요에 따라 대체해야됨에 유의하자.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># your_own_table.sql</span></span><br><span class="line"></span><br><span class="line"><span class="string">CREATE</span> <span class="string">TABLE</span> <span class="string">Tablename(</span></span><br><span class="line">    <span class="string">YOUR_OWN_CODE;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create_table.sh</span></span><br><span class="line"></span><br><span class="line">CONTAINER_NAME=mssql_service</span><br><span class="line">DB_USER=SA</span><br><span class="line">DB_PASS=YOUR_OWN_PASSWORD</span><br><span class="line">DB_NAME=master</span><br><span class="line"></span><br><span class="line">SQL_SCRIPT=./data/your_own_table.sql</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$CONTAINER_NAME</span> /opt/mssql-tools/bin/sqlcmd \</span><br><span class="line">    -S localhost -U <span class="variable">$DB_USER</span> -P <span class="variable">$DB_PASS</span> -d <span class="variable">$DB_NAME</span> \</span><br><span class="line">    -i <span class="variable">$SQL_SCRIPT</span></span><br></pre></td></tr></table></figure><p>이후 해당 스크립트를 실행함으로써 도커 내부로 진입 없이 테이블 생성을 할 수 있다. 마찬가지로 아래 스크립트를 통해 해당 테이블로부터 데이터 조회를 자동화하였다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get_table_data.sh</span></span><br><span class="line"></span><br><span class="line">CONTAINER_NAME=mssql_service</span><br><span class="line">DB_USER=SA</span><br><span class="line">DB_PASS=YOUR_OWN_PASSWORD</span><br><span class="line">DB_NAME=master</span><br><span class="line"></span><br><span class="line">SQL_SCRIPT=./data/secom_workhistory.sql</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$CONTAINER_NAME</span> /opt/mssql-tools/bin/sqlcmd \</span><br><span class="line">    -S localhost -U <span class="variable">$DB_USER</span> -P <span class="variable">$DB_PASS</span> \</span><br><span class="line">    -Q <span class="string">&quot;SELECT * FROM YOUR_ONW_TABLE&quot;</span></span><br></pre></td></tr></table></figure><p>추가로 별도의 프로그램을 통해 해당 데이터베이스로의 접근을 희망할 경우, 아래 정보를 통해 본인의 클라우드 서버 내 MS SQL로 진입할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host : &lt;공인 IP&gt;</span><br><span class="line">Port : &lt;ACG에 등록한 포트 번호&gt;</span><br><span class="line">Database : master</span><br><span class="line">Table : YOUR_OWN_TABLE</span><br><span class="line">Username : SA</span><br><span class="line">Password : YOUR_OWN_PASSWORD</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h1 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h1><p>Naver Cloud Platform (NCP) Server 생성, Putty 접속(<a href="https://seokd.tistory.com/40">https://seokd.tistory.com/40</a>)</p><p>Mac Pro 터미널을 이용해서 Remote 서버 SSH 접속 하기(<a href="https://page-view.tistory.com/32">https://page-view.tistory.com/32</a>)</p><p>네이버클라우드 적용기 - 공인 IP 생성 및 포트 포워딩, SSH 연결(<a href="https://catchdream.tistory.com/230">https://catchdream.tistory.com/230</a>)</p><p>네이버 클라우드 DB서버에 공인IP 없이 외부 원격 접속하기(<a href="https://prohannah.tistory.com/93">https://prohannah.tistory.com/93</a>)</p><p>Naver Cloud Platform 서버 세팅하기(<a href="https://eitu97.tistory.com/58">https://eitu97.tistory.com/58</a>)</p><p>Server 생성 후 SSH접속 및 Public IP 연결하여 외부 접속 방법(<a href="https://photofrontbboggi.tistory.com/entry/%EB%84%A4%EC%9D%B4%EB%B2%84%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%ED%94%8C%EB%9E%AB%ED%8F%BC-Server-%EC%83%9D%EC%84%B1-%ED%9B%84-SSH%EC%A0%91%EC%86%8D-%EB%B0%8F-Public-IP-%EC%97%B0%EA%B2%B0%ED%95%98%EC%97%AC-%EC%99%B8%EB%B6%80-%EC%A0%91%EC%86%8D-%EB%B0%A9%EB%B2%95">https://photofrontbboggi.tistory.com/entry/네이버클라우드플랫폼-Server-생성-후-SSH접속-및-Public-IP-연결하여-외부-접속-방법</a>)</p><p>Ubuntu 18.04.x LTS에 docker 설치 하기(<a href="https://louky0714.tistory.com/131">https://louky0714.tistory.com/131</a>)</p><p>Docker로 MS-SQL Server 설치하기(<a href="https://www.lesstif.com/dbms/docker-ms-sql-server-113347394.html">https://www.lesstif.com/dbms/docker-ms-sql-server-113347394.html</a>)</p><p>MSSQL을 Docker Compose로 띄우기(<a href="https://basketdeveloper.tistory.com/89">https://basketdeveloper.tistory.com/89</a>)</p><p>MSSQL 기본 명령어 정리(<a href="https://kindmaster.tistory.com/188">https://kindmaster.tistory.com/188</a>)</p>]]></content:encoded>
      
      
      <category domain="https://bigpie1367.github.io/categories/Infra/">Infra</category>
      
      
      <category domain="https://bigpie1367.github.io/tags/Infra-DevOps-Naver-NCP-MSSQL/">Infra, DevOps, Naver, NCP, MSSQL</category>
      
      
      <comments>https://bigpie1367.github.io/2024/01/16/NCP-MS-SQL-in-macOS/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS EC2 Jenkins를 통한 CI 환경 구축</title>
      <link>https://bigpie1367.github.io/2024/01/11/AWS-EC2-Jenkins%EB%A5%BC-%ED%86%B5%ED%95%9C-CI-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/</link>
      <guid>https://bigpie1367.github.io/2024/01/11/AWS-EC2-Jenkins%EB%A5%BC-%ED%86%B5%ED%95%9C-CI-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/</guid>
      <pubDate>Wed, 10 Jan 2024 23:28:47 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://bigpie1367.github.io/2024/01/05/Web-Server%EB%B6%80%ED%84%B0-Nginx%EA%B9%8C%EC%A7%80/&quot;&gt;이전 글&lt;/a&gt;을 통해 &lt;strong&gt;Docker-compose&lt;/strong&gt; 구성을 통한 각 서버별 &lt;strong&gt;Docker Container&lt;/strong&gt;들을 구성하였는데, 진행하다 보니 &lt;strong&gt;CI&lt;/strong&gt; 자동화도 알아보고 싶어 이에 대해 다루고자 한다. 본 글에서는 &lt;strong&gt;AWS EC2&lt;/strong&gt; 인스턴스 내 &lt;strong&gt;Jenkins&lt;/strong&gt;를 통해 &lt;strong&gt;CI&lt;/strong&gt; 자동화에 대해 다루고자 한다. 현재 회사 특성상 &lt;strong&gt;CD&lt;/strong&gt; 까지 진행하는데 어려움이 있을 듯 해 ‘&lt;strong&gt;CI&amp;#x2F;CD&lt;/strong&gt;’가 아닌, &lt;strong&gt;CI&lt;/strong&gt;만을 다루고자 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;&lt;/p&gt;
&lt;h1 id=&quot;본론&quot;&gt;&lt;a href=&quot;#본론&quot; class=&quot;headerlink&quot; title=&quot;본론&quot;&gt;&lt;/a&gt;본론&lt;/h1&gt;&lt;h2 id=&quot;CI-CD-란&quot;&gt;&lt;a href=&quot;#CI-CD-란&quot; class=&quot;headerlink&quot; title=&quot;CI&amp;#x2F;CD 란?&quot;&gt;&lt;/a&gt;CI&amp;#x2F;CD 란?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;CI&lt;/strong&gt; &amp;#x3D; 지속적인 통합(Continuous Integration)을 의미하는 단어로 ‘빌드와 테스트’를 자동화한 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CD&lt;/strong&gt; &amp;#x3D; 지속적인 전달(Continuous Delivery) or 지속적인 배포(Continuous Deployment)를 의미하는 단어로 CI가 완료된 이후 사용자에게 전달하는 배포 과정을 자동화한 것이다.&lt;/p&gt;
&lt;p&gt;즉, &lt;strong&gt;CI&lt;/strong&gt;는 개발 과정에서 필요한 빌드 및 테스트 단계를 자동화한 것이고 &lt;strong&gt;CD&lt;/strong&gt;는 테스트가 완료된 코드를 사용자에게 전달하기 위한 도구이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2 id=&quot;프로젝트-구성&quot;&gt;&lt;a href=&quot;#프로젝트-구성&quot; class=&quot;headerlink&quot; title=&quot;프로젝트 구성&quot;&gt;&lt;/a&gt;프로젝트 구성&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p><a href="https://bigpie1367.github.io/2024/01/05/Web-Server%EB%B6%80%ED%84%B0-Nginx%EA%B9%8C%EC%A7%80/">이전 글</a>을 통해 <strong>Docker-compose</strong> 구성을 통한 각 서버별 <strong>Docker Container</strong>들을 구성하였는데, 진행하다 보니 <strong>CI</strong> 자동화도 알아보고 싶어 이에 대해 다루고자 한다. 본 글에서는 <strong>AWS EC2</strong> 인스턴스 내 <strong>Jenkins</strong>를 통해 <strong>CI</strong> 자동화에 대해 다루고자 한다. 현재 회사 특성상 <strong>CD</strong> 까지 진행하는데 어려움이 있을 듯 해 ‘<strong>CI&#x2F;CD</strong>’가 아닌, <strong>CI</strong>만을 다루고자 한다.</p><p>&nbsp;<br>&nbsp;</p><h1 id="본론"><a href="#본론" class="headerlink" title="본론"></a>본론</h1><h2 id="CI-CD-란"><a href="#CI-CD-란" class="headerlink" title="CI&#x2F;CD 란?"></a>CI&#x2F;CD 란?</h2><p><strong>CI</strong> &#x3D; 지속적인 통합(Continuous Integration)을 의미하는 단어로 ‘빌드와 테스트’를 자동화한 것이다.</p><p><strong>CD</strong> &#x3D; 지속적인 전달(Continuous Delivery) or 지속적인 배포(Continuous Deployment)를 의미하는 단어로 CI가 완료된 이후 사용자에게 전달하는 배포 과정을 자동화한 것이다.</p><p>즉, <strong>CI</strong>는 개발 과정에서 필요한 빌드 및 테스트 단계를 자동화한 것이고 <strong>CD</strong>는 테스트가 완료된 코드를 사용자에게 전달하기 위한 도구이다.</p><p>&nbsp;</p><h2 id="프로젝트-구성"><a href="#프로젝트-구성" class="headerlink" title="프로젝트 구성"></a>프로젝트 구성</h2><img width="1200" alt="스크린샷 2024-01-11 오전 7 47 01" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/a15be20e-6b0f-44f2-98a0-41f34efc4ff3"><center>프로젝트 전체 구성도</center><p>&nbsp;</p><p>전체 프로젝트 구성은 위 사진과 같다. 사용자가 코드를 깃 저장소에 올릴 경우 <strong>Github Webhook</strong>을 통해 해당 코드 내용을 <strong>Jenkins Docker Container</strong>에 반영한다. 이후 <strong>Jenkins</strong>가 <strong>Migration, Test</strong>를 비롯한 일련의 작업들을 수행하는 구조이다.</p><p>위에서 언급했듯이 본 프로젝트에서는 <strong>CI</strong> 환경 구축만을 목표로 하였기 때문에 별도의 <strong>Docker</strong> <strong>Hub</strong>와의 연결 없이 테스트 단계에서 마무리하도록 하겠다.</p><p>&nbsp;</p><h2 id="AWS-EC2-인스턴스-생성"><a href="#AWS-EC2-인스턴스-생성" class="headerlink" title="AWS EC2 인스턴스 생성"></a>AWS EC2 인스턴스 생성</h2><p>EC2에 대해 보다 자세히 다룬 글들이 존재하기에 참조할만한 링크만 추가한 뒤 본 글에서는 EC2 인스턴스를 통해 자동화하는 과정에 대해 집중적으로 다루고자 한다.</p><blockquote><p><a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html">Amazon EC2란 무엇인가요?</a></p></blockquote><p>기존 활용하던 인스턴스가 아닌 새로 인스턴스를 생성하여 설명하도록 하겠다. 추가로 본 글에서는 ‘프리 티어’를 기준으로 설명하므로 이를 인지하고 살펴볼 필요가 있다.</p><p>&nbsp;</p><h3 id="신규-인스턴스-생성"><a href="#신규-인스턴스-생성" class="headerlink" title="신규 인스턴스 생성"></a>신규 인스턴스 생성</h3><p>상단 레드박스 내 버튼을 통해 신규 인스턴스를 생성할 수 있다</p><img width="1792" alt="스크린샷 2024-01-09 오전 8 26 50" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/e8d7dcef-00e7-4be5-a57a-16414b8e77c9"><center>인스턴스 목록 화면</center><p>&nbsp;</p><h3 id="Application-and-OS-Images"><a href="#Application-and-OS-Images" class="headerlink" title="Application and OS Images"></a>Application and OS Images</h3><p><strong>AMI</strong>(<strong>Amazon Machine Image</strong>)는 해당 <strong>EC2</strong> 인스턴스의 베이스가 될 OS를 선택하는 것인데, 본 글에서는 <code>Amazon Linux 2</code>를 기준으로 설명하고자 한다. <code>Ubuntu</code>를 기준으로 하고자 할 경우 다른 AMI를 선택하면 된다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 8 28 42" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/bd4108bb-09c7-4413-bcda-13d448299270"><center>인스턴스 생성 초기 화면</center><p>&nbsp;</p><img width="1792" alt="스크린샷 2024-01-09 오전 8 36 06" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/df1cb8a9-b6d2-45cf-8a83-4eb30aa86fed"><center>Amazon Linux 2 기준</center><p>&nbsp;</p><h3 id="인스턴스-유형-및-키-페어"><a href="#인스턴스-유형-및-키-페어" class="headerlink" title="인스턴스 유형 및 키 페어"></a>인스턴스 유형 및 키 페어</h3><p>인스턴스도 마찬가지로 기본 인스턴스인 t2.micro를 활용할 예정이다. 다음으로 중요한 부분은 키페어에 관련된 부분인데, 추후 해당 키 페어를 통해 SSH 접속에 활용할 예정이니 주의깊게 살펴야 한다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 8 38 53" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/27d17ec7-87fa-4eb2-a340-4e02f383b56e"><center>키 페어 설정 화면</center><p>&nbsp;</p><p>키페어 이름을 설정한 뒤 생성을 하면 로컬에 키페어가 다운로드 된다. 추후 해당 키페어가 위치한 디렉토리에서 SSH 접속을 해야하므로 안전한 곳에 보관하면 된다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 8 44 34" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/f5f8291a-497e-47df-b18f-338267e2467c"><center>키 페어 생성 화면</center><p>&nbsp;</p><h3 id="네트워크-구성"><a href="#네트워크-구성" class="headerlink" title="네트워크 구성"></a>네트워크 구성</h3><p>네트워크 구성의 경우 외부에서 Jenkins 접근을 허용하기 위해 <code>8080</code> 포트를 추가로 개방해주었다. 특정 포트에 대해 외부로부터의 접근을 허용하는 것을 ‘인바운드 규칙’이라 하는데, 본 글에서는 <code>8080</code> 포트만 활용할 예정이므로 추가적으로 이에 대해 다루진 않겠다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 8 49 22" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/ed7d7b84-b42c-4473-9966-0f374a05d2f5"><center>인바운드 보안 그룹 설정 화면</center><p>&nbsp;</p><h3 id="인스턴스-생성-완료"><a href="#인스턴스-생성-완료" class="headerlink" title="인스턴스 생성 완료"></a>인스턴스 생성 완료</h3><p>상기 과정을 완료했다면 아래 이미지처럼 인스턴스가 성공적으로 생성되었음을 확인할 수 있다</p><img width="1792" alt="스크린샷 2024-01-09 오전 8 53 21" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/2ff3b027-2bda-4add-92a8-5fa37bc7b3c8"><center>인스턴스 생성 완료시 화면</center><p>&nbsp;</p><h3 id="인스턴스-접근"><a href="#인스턴스-접근" class="headerlink" title="인스턴스 접근"></a>인스턴스 접근</h3><p>정상적으로 인스턴스 생성이 완료되었다면 이전 과정에서 생성한 키 페어를 통해 인스턴스 내부에 접근할 수 있다. 본인의 키 페어가 위치한 디렉토리에서 <code>ssh -i &lt;키페어 이름&gt;.pem ec2-user@&lt;퍼블릭 IP&gt;</code> 를 통해 인스턴스 내부로 접근할 수 있다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 8 59 25" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/4aba660c-54b9-4eb6-9731-c509401e6fab"><center>SSH를 통한 인스턴스 접근 화면</center><p>&nbsp;</p><p>그런데 접근을 시도할 경우 위 이미지처럼 에러가 발생함을 확인할 수 있다. 이는 최초 다운로드된 키 페어의 경우 접근 권한이 외부인에게도 허용된 상태이기 때문인데, <code>sudo chmod 400 test.pem</code>  명령어를 통해 해당 키 페어의 권한을 변경해주면 정상적으로 인스턴스에 접근할 수 있다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 9 09 25" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/9808cd37-d495-4709-b272-5849066430d8"><center>인스턴스 접근에 성공할 시 화면</center><p>&nbsp;<br>&nbsp;</p><h2 id="Jenkins-설치-설정"><a href="#Jenkins-설치-설정" class="headerlink" title="Jenkins 설치 &amp; 설정"></a>Jenkins 설치 &amp; 설정</h2><p>본 글에서는 EC2 인스턴스 내 도커를 설치한 뒤, Jenkins Container를 띄울 예정이다. Docker 내부에 Jenkins를 설치하지 않고 EC2 자체에 Jenkins를 설치하는 방법도 존재하나, 설치 및 관리의 편의성으로 인해 이러한 방법을 채택하였다.</p><p>아래 일련의 명령어를 수행함으로써 필수 패키지 및 Docker를 설치할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 패키지 업데이트</span></span><br><span class="line">sudo yum update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 관련 패키지 설치</span></span><br><span class="line">sudo yum install docker docker.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 서비스 실행</span></span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 사용자를 User Group에 추가</span></span><br><span class="line">sudo usermod -a -G docker <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 부팅 시 Docker 자동 시작</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 권한 설정</span></span><br><span class="line">newgrp docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker-compose 설치</span></span><br><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(<span class="built_in">uname</span> -s)-$(<span class="built_in">uname</span> -m) -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker-compose 권한 부여</span></span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>위 과정을 완료하였다면 아래 명령어들을 통해 정상적으로 설치 및 실행이 완료되었음을 확인할 수 있다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Docker 설치 확인</span></span><br><span class="line">[ec2-user@ip-172-31-6-223 ~]$ docker -v</span><br><span class="line">Docker version 20.10.25, build b82b9f3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 실행 확인</span></span><br><span class="line">[ec2-user@ip-172-31-6-223 ~]$ sudo systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 화 2024-01-09 00:54:38 UTC; 33min ago</span><br><span class="line"></span><br><span class="line">(중략)</span><br></pre></td></tr></table></figure><p>이후 <code>docker-compose.yml</code> 파일을 통해 Jenkins Container를 구성해보겠다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd : /home/ec2-user/docker-compsoe.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">jenkins:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">jenkins/jenkins:lts</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">jenkins</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock.</span>   <span class="comment"># 컨테이너 내 Docker 실행을 위함</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/jenkins:/var/jenkins_home</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">true</span>    <span class="comment"># 컨테이너 내부 자원 접근을 위함</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">root</span>          <span class="comment"># root 권한 설정</span></span><br></pre></td></tr></table></figure><p>아래 명령어들을 통해 도커 생성 및 확인을 할 수 있다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd : /home/ec2-user</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker-compose 실행</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker container 확인</span></span><br><span class="line">docker ps</span><br><span class="line">CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS         PORTS                                                  NAMES</span><br><span class="line">07b7e38fdd22   jenkins/jenkins:lts   <span class="string">&quot;/usr/bin/tini -- /u…&quot;</span>   2 minutes ago   Up 2 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp, 50000/tcp   jenkins</span><br></pre></td></tr></table></figure><p>상기 과정을 모두 정상적으로 수행하였다면 브라우저 상에서 <code>&lt;퍼블릭 IP&gt;:8080</code> 을 통해 Jenkins를 사용할 수 있다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 10 39 21" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/faab1412-d2e7-4e89-b7d1-1956ecd674d2"><center>Jenkins 초기 화면</center><p>&nbsp;</p><p>Jenkins를 활성화하기 위한 비밀번호는 <code>docker logs &lt;container 이름&gt;</code> 명령어를 통해 확인할 수 있다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 10 45 05" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/5ff33a46-4cf7-4a46-8be9-b2f48987f38a"><center>Jenkins 활성화를 위한 비밀번호</center><p>&nbsp;</p><p>이후 패키지를 설치할 수 있는데, 대부분 좌측 기본 패키지 설치하는 것을 권장한다</p><img width="1792" alt="스크린샷 2024-01-09 오전 10 47 03" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/f5f46965-0b5f-425a-a341-ce4ac4705183"><center>Jenkins 패키지 설치 화면</center><p>&nbsp;</p><p>패키지 설치를 완료한 뒤 로그인에 사용할 관리자 계정을 생성해주면 Jenkins 설정은 끝이다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 10 48 26" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/abea3dfd-4bc2-4bda-b51e-d0d5ba20c39b"><center>설정을 완료한 뒤 Jenkins 화면</center><p>&nbsp;<br>&nbsp;</p><h2 id="Github-Webhook-연결"><a href="#Github-Webhook-연결" class="headerlink" title="Github Webhook 연결"></a>Github Webhook 연결</h2><p>Github Webhook을 통해 Github 저장소에 코드가 변경될 경우(push, merge request, …) 자동적으로 빌드를 수행하게끔 하고자 한다. Github 저장소와의 연결을 위해 Credential을 만들어야 한다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 10 54 08" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/3f2a682f-b554-4997-9245-b7c6530ae409"><center>Jenkins Credential 설정 화면 - 1</center><p>&nbsp;</p><img width="1792" alt="스크린샷 2024-01-09 오전 10 55 40" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/e96f9a8d-56ac-4ac0-bb13-f7818ce9f7fd"><center>Jenkins Credential 설정 화면 - 2</center><p>&nbsp;</p><img width="1792" alt="스크린샷 2024-01-09 오전 10 55 47" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/ba7ef3e0-8133-430f-a6e4-9856cd4100e3"><center>Jenkins Credential 설정 화면 - 3</center><p>&nbsp;</p><p>아래 페이지에서 <code>username</code> : Github ID, <code>Password</code> : Github Access Token 를 입력한 뒤 <code>ID</code> 는 자유롭게 입력하면 된다. <code>ID</code> 를 입력하지 않을 경우 자동으로 생성되나 구분을 위해 별도로 선언하는 편이 좋다.</p><p><img src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/48c2ea6d-6d65-401e-ab7b-0b2a49a11d7e" alt="스크린샷 2024-01-09 오전 10 56 14"></p><center>Jenkins Credential 설정 화면 - 4</center><p>&nbsp;</p><p>이후 연결하고자 하는 저장소에 들어간 뒤 Webhook을 설정할 수 있다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 11 19 23" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/31edfa87-12ad-4add-acba-012e537d557c"><center>Github 저장소 내 Webhook 설정 - 1</center><p>&nbsp;</p><p>Payload URL에 <code>http://&lt;퍼블릭 IP&gt;:8080/github-webhook/</code> 로 설정하면 된다.</p><img width="1792" alt="스크린샷 2024-01-09 오전 11 23 01" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/483dca80-f6c4-493c-a1c1-44c2324775ef"><center>Github 저장소 내 Webhook 설정 - 2</center><p>&nbsp;</p><p>Github와 연결을 완료하였으니 코드가 수정될 경우 수행할 작업들을 정의하도록 하겠다.</p><img width="1792" alt="스크린샷 2024-01-09 오후 3 30 01" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/f3b3ba62-bb6c-48d7-829e-1964bbabaf2f"><center>Jenkins Job 설정 화면 - 1</center><p>&nbsp;</p><img width="1792" alt="스크린샷 2024-01-09 오후 3 30 29" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/93af2d6f-b7d3-4655-a8ab-cc1471e08d44"><center>Jenkins Job 설정 화면 - 2</center><p>&nbsp;</p><p>아래 이미지와 마찬가지로 ‘소스 코드 관리’ 탭에서 연결하고자 하는 Git 주소, Credential, Branch를 설정해주었다. 필자는 <code>main</code> branch 기준이므로 수정하였다.</p><img width="1792" alt="스크린샷 2024-01-09 오후 3 43 07" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/b8455e3d-16b8-4b51-85ac-5297f4862f67"><center>Jenkins Job 설정 화면 - 브랜치 설정</center><p>&nbsp;</p><p>이후 ‘빌드 유발’ 탭에서 Github Webhook과 관련된 <code>GitHub hook trigger for GITScm polling</code> 옵션을 활성화해준 뒤, ‘Build Steps’에서 <code>Execute Shell</code> 탭을 선택한 뒤 수행할 일련의 명령어들을 정의하였다.</p><img width="1792" alt="스크린샷 2024-01-09 오후 3 48 20" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/cc7b35fe-d91c-4d1f-a45e-18f4a967da10"><center>Jenkins Job 설정 화면 - 빌드 명령어 설정</center><p>&nbsp;</p><p>참고로 필자의 경우 실제론 Postgresql, Django, Nginx 3개의 Docker-compose로 구성된 환경이나 Jenkins 내부에서는 Django에 대한 테스트를 수행할 것이므로 위와 같이 빌드 명령어를 작성하였다.</p><p>또한 위 명령어는 Jenkins Docker Container 내부에서 수행되는데, 현재 해당 Conatiner 내부에는 파이썬을 비롯한 별도의 패키지들이 설치되어 있지 않다. 따라서 아래 명령어를 통해 이를 설치하고자 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Container 진입을 위한 명령어</span></span><br><span class="line">docker <span class="built_in">exec</span> -it --user root &lt;container 이름&gt; /bin/bash</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 패키지 업데이트</span></span><br><span class="line">apt-get update -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필수 패키지 설치</span></span><br><span class="line">apt-get install -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 설치</span></span><br><span class="line">apt-get install docker.io -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># python &amp; pip 설치</span></span><br><span class="line">apt-get install python3 pip -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Django 설치</span></span><br><span class="line">apt-get install python3-django</span><br></pre></td></tr></table></figure><p>이후 연결한 Github 저장소에 들어가 코드를 수정하면 아래와 같이 Jenkins에서 빌드가 수행됨을 확인할 수 있다.</p><img width="1788" alt="스크린샷 2024-01-09 오후 4 58 32" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/bd5a1094-8f0b-4986-bb8e-4cac1c4b6561"><center>Jenkins 빌드 수행 화면 - 진행중</center><p>&nbsp;</p><img width="1792" alt="스크린샷 2024-01-09 오후 4 58 41" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/4905fe87-942c-4227-8ab8-c3566cf7708a"><center>Jenkins 빌드 수행 화면 - 성공</center><p>&nbsp;</p><h1 id="참고-문헌"><a href="#참고-문헌" class="headerlink" title="참고 문헌"></a>참고 문헌</h1><p><a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html">Amazon EC2란 무엇인가요?</a>)</p><p><a href="https://www.itworld.co.kr/news/107527">젠킨스란 무엇인가, CI(Continuous Integration) 서버의 이해</a>)</p><p><a href="https://sws1223.tistory.com/9">Django + jenkins + docker CI&#x2F;CD 구축기</a>)</p><p><a href="https://velog.io/@tank3a/AWS%EC%97%90-Jenkins%EB%A5%BC-%EA%B5%AC%EC%B6%95%ED%95%B4%EB%B3%B4%EC%9E%90-3-Jenkins-%EC%B4%88%EA%B8%B0%EC%84%A4%EC%A0%95">AWS에 Jenkins를 구축해보자</a>)</p><p><a href="https://junhyunny.github.io/information/jenkins/github/jenkins-github-webhook/">젠킨스(Jenkins) Github Webhooks 연결</a>)</p><p><a href="https://junhyunny.github.io/information/docker/make-private-docker-registry-on-ec2/">비공개 도커 레지스트리(private docker registry) 만들기</a>)</p><p><a href="https://syaamex.hashnode.dev/devops-project-jenkins-cicd">End to End Project: Deployed Django Application with Jenkins CI&#x2F;CD Pipeline</a>)</p><p><a href="https://tape22.tistory.com/16">Springboot Gradle + AWS EC2 + Jenkins + Docker로 배포까지</a>)</p><p><a href="https://data-make.tistory.com/772">[AWS EC2] Jenkins in Docker 배포 자동화 구축</a>)</p><p><a href="https://www.dongyeon1201.kr/9026133b-31be-4b58-bcc7-49abbe893044">Jenkins를 활용한 DevOps 환경 구축</a>)</p><p><a href="https://www.lechuck.blog/post/AWS-EC2%EC%97%90-Docker-Compose-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0">AWS EC2에 Docker-Compose 구축하기</a>)</p>]]></content:encoded>
      
      
      <category domain="https://bigpie1367.github.io/categories/Infra/">Infra</category>
      
      
      <category domain="https://bigpie1367.github.io/tags/Infra-DevOps-Amazon-AWS-Jenkins-CI-CD-CI/">Infra, DevOps, Amazon, AWS, Jenkins, CI/CD, CI</category>
      
      
      <comments>https://bigpie1367.github.io/2024/01/11/AWS-EC2-Jenkins%EB%A5%BC-%ED%86%B5%ED%95%9C-CI-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Web Server부터 Nginx까지</title>
      <link>https://bigpie1367.github.io/2024/01/05/Web-Server%EB%B6%80%ED%84%B0-Nginx%EA%B9%8C%EC%A7%80/</link>
      <guid>https://bigpie1367.github.io/2024/01/05/Web-Server%EB%B6%80%ED%84%B0-Nginx%EA%B9%8C%EC%A7%80/</guid>
      <pubDate>Fri, 05 Jan 2024 03:42:10 GMT</pubDate>
      
      <description>&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h1 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;(&lt;strong&gt;엔진엑스&lt;/strong&gt;) 에 대해 찾아보는 와중 기존 내가 알고있던 &lt;strong&gt;웹 서버&lt;/strong&gt;(&lt;strong&gt;Web Server&lt;/strong&gt;)에 대한 개념이 상충하는 것이 있어 이를 정리하고자 한다. 본 글에서는 &lt;strong&gt;Web Server&lt;/strong&gt;와 &lt;strong&gt;WAS&lt;/strong&gt;의 개념 비교부터 시작하여 가장 보편적으로 사용되는 &lt;strong&gt;Web Server&lt;/strong&gt; 엔진 및 실제 사용될 수 있는 프로젝트 구성을 &lt;strong&gt;Docker-compose&lt;/strong&gt;를 통해 구성해보고자 한다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;&lt;/p&gt;
&lt;h1 id=&quot;본론&quot;&gt;&lt;a href=&quot;#본론&quot; class=&quot;headerlink&quot; title=&quot;본론&quot;&gt;&lt;/a&gt;본론&lt;/h1&gt;&lt;h2 id=&quot;Web-Server&quot;&gt;&lt;a href=&quot;#Web-Server&quot; class=&quot;headerlink&quot; title=&quot;Web Server&quot;&gt;&lt;/a&gt;Web Server&lt;/h2&gt;&lt;p&gt;위키백과에 정의된 웹 서버에 대한 정의는 다음과 같다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%94%EB%93%9C_%EC%99%80%EC%9D%B4%EB%93%9C_%EC%9B%B9&quot;&gt;웹&lt;/a&gt; &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B2%84&quot;&gt;서버&lt;/a&gt;&lt;/strong&gt;(Web server)는 다음의 두 가지 뜻 가운데 하나이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;웹 서버: &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80&quot;&gt;웹 브라우저&lt;/a&gt;와 같은 클라이언트로부터 &lt;a href=&quot;https://ko.wikipedia.org/wiki/HTTP&quot;&gt;HTTP&lt;/a&gt; 요청을 받아들이고, &lt;a href=&quot;https://ko.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; 문서와 같은 웹 페이지를 반환하는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8&quot;&gt;컴퓨터 프로그램&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;웹 서버 (하드웨어): 위에 언급한 기능을 제공하는 컴퓨터 프로그램을 실행하는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0&quot;&gt;컴퓨터&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;웹 서버&lt;/strong&gt;(web server)는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/HTTP&quot;&gt;HTTP&lt;/a&gt; 또는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/HTTPS&quot;&gt;HTTPS&lt;/a&gt;를 통해 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80&quot;&gt;웹 브라우저&lt;/a&gt;에서 요청하는 [HTML 문서나 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8&quot;&gt;오브젝트&lt;/a&gt;(&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%AF%B8%EC%A7%80_%ED%8C%8C%EC%9D%BC&quot;&gt;이미지 파일&lt;/a&gt; 등)을 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_(%EC%BB%B4%ED%93%A8%ED%8C%85)&quot;&gt;전송&lt;/a&gt;해주는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B9%84%EC%8A%A4%ED%98%95_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4&quot;&gt;서비스 프로그램&lt;/a&gt;을 말한다. 웹 서버 소프트웨어를 구동하는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4&quot;&gt;하드웨어&lt;/a&gt;도 웹 서버라고 해서 혼동하는 경우가 간혹 있다.&lt;/p&gt;
&lt;p&gt;출처 : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%B9_%EC%84%9C%EB%B2%84&quot;&gt;https://ko.wikipedia.org/wiki/웹_서버&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위에 정의된 바와 같이 &lt;strong&gt;웹 서버&lt;/strong&gt;란 &lt;strong&gt;HTTP, HTTPS&lt;/strong&gt; 통신 프로토콜을 통해 사용자가 요청하는 &lt;strong&gt;HTML 문서&lt;/strong&gt;나 &lt;strong&gt;오브젝트&lt;/strong&gt;, 즉 &lt;strong&gt;정적인 파일&lt;/strong&gt;들을 전달해주는 서비스 프로그램을 말한다. 다만 이러한 정적인 페이지들의 경우 과거에는 충분하였을 지 모르나 기술이 발달한 요즘 시대에는 부족한 것이 사실이다. 이러한 태생적인 한계를 극복하기 위한 것이 &lt;strong&gt;WAS(Web Application Server)&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>&nbsp;</p><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p><strong>Nginx</strong>(<strong>엔진엑스</strong>) 에 대해 찾아보는 와중 기존 내가 알고있던 <strong>웹 서버</strong>(<strong>Web Server</strong>)에 대한 개념이 상충하는 것이 있어 이를 정리하고자 한다. 본 글에서는 <strong>Web Server</strong>와 <strong>WAS</strong>의 개념 비교부터 시작하여 가장 보편적으로 사용되는 <strong>Web Server</strong> 엔진 및 실제 사용될 수 있는 프로젝트 구성을 <strong>Docker-compose</strong>를 통해 구성해보고자 한다.</p><p>&nbsp;<br>&nbsp;</p><h1 id="본론"><a href="#본론" class="headerlink" title="본론"></a>본론</h1><h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><p>위키백과에 정의된 웹 서버에 대한 정의는 다음과 같다</p><blockquote><p><strong><a href="https://ko.wikipedia.org/wiki/%EC%9B%94%EB%93%9C_%EC%99%80%EC%9D%B4%EB%93%9C_%EC%9B%B9">웹</a> <a href="https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B2%84">서버</a></strong>(Web server)는 다음의 두 가지 뜻 가운데 하나이다.</p><ol><li>웹 서버: <a href="https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80">웹 브라우저</a>와 같은 클라이언트로부터 <a href="https://ko.wikipedia.org/wiki/HTTP">HTTP</a> 요청을 받아들이고, <a href="https://ko.wikipedia.org/wiki/HTML">HTML</a> 문서와 같은 웹 페이지를 반환하는 <a href="https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8">컴퓨터 프로그램</a></li><li>웹 서버 (하드웨어): 위에 언급한 기능을 제공하는 컴퓨터 프로그램을 실행하는 <a href="https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0">컴퓨터</a></li></ol><p><strong>웹 서버</strong>(web server)는 <a href="https://ko.wikipedia.org/wiki/HTTP">HTTP</a> 또는 <a href="https://ko.wikipedia.org/wiki/HTTPS">HTTPS</a>를 통해 <a href="https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80">웹 브라우저</a>에서 요청하는 [HTML 문서나 <a href="https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8">오브젝트</a>(<a href="https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%AF%B8%EC%A7%80_%ED%8C%8C%EC%9D%BC">이미지 파일</a> 등)을 <a href="https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_(%EC%BB%B4%ED%93%A8%ED%8C%85)">전송</a>해주는 <a href="https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B9%84%EC%8A%A4%ED%98%95_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4">서비스 프로그램</a>을 말한다. 웹 서버 소프트웨어를 구동하는 <a href="https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4">하드웨어</a>도 웹 서버라고 해서 혼동하는 경우가 간혹 있다.</p><p>출처 : <a href="https://ko.wikipedia.org/wiki/%EC%9B%B9_%EC%84%9C%EB%B2%84">https://ko.wikipedia.org/wiki/웹_서버</a></p></blockquote><p>위에 정의된 바와 같이 <strong>웹 서버</strong>란 <strong>HTTP, HTTPS</strong> 통신 프로토콜을 통해 사용자가 요청하는 <strong>HTML 문서</strong>나 <strong>오브젝트</strong>, 즉 <strong>정적인 파일</strong>들을 전달해주는 서비스 프로그램을 말한다. 다만 이러한 정적인 페이지들의 경우 과거에는 충분하였을 지 모르나 기술이 발달한 요즘 시대에는 부족한 것이 사실이다. 이러한 태생적인 한계를 극복하기 위한 것이 <strong>WAS(Web Application Server)</strong> 이다.</p><p>&nbsp;<br>&nbsp;</p><h2 id="WAS-Web-Application-Server"><a href="#WAS-Web-Application-Server" class="headerlink" title="WAS (Web Application Server)"></a>WAS (Web Application Server)</h2><p>마찬가지로 위키백과에 정의된 웹 어플리케이션 서버에 대한 정의는 다음과 같다.</p><blockquote><p><strong>웹 애플리케이션 서버</strong>(Web Application Server, 약자 <strong>WAS</strong>)는 <a href="https://ko.wikipedia.org/wiki/%EC%9B%B9_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98">웹 애플리케이션</a>과 <a href="https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B2%84">서버</a> 환경을 만들어 동작시키는 기능을 제공하는 <a href="https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC">소프트웨어 프레임워크</a>이다.<a href="https://ko.wikipedia.org/wiki/%EC%9B%B9_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98_%EC%84%9C%EB%B2%84#cite_note-1">[1]</a> 인터넷 상에서 <a href="https://ko.wikipedia.org/wiki/HTTP">HTTP</a>를 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해 주는 <a href="https://ko.wikipedia.org/wiki/%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4">미들웨어</a>(소프트웨어 엔진)로 볼 수 있다. 웹 애플리케이션 서버는 동적 서버 콘텐츠를 수행하는 것으로 일반적인 웹 서버와 구별이 되며, 주로 데이터베이스 서버와 같이 수행이 된다. 한국에서는 일반적으로 “WAS” 또는 “WAS S&#x2F;W”로 통칭하고 있으며 공공기관에서는 “웹 응용 서버”로 사용되고, 영어권에서는 “Application Server” (약자 AS)로 불린다.</p><p>출처 : <a href="https://en.wikipedia.org/wiki/Application_server">https://en.wikipedia.org/wiki/Application_server</a></p></blockquote><p>즉 <strong>웹 애플리케이션 서버</strong>(이후 WAS)는 우리가 통상적으로 인식하고 있는 웹 서버의 개념과 동일하다고 보면 된다. 사용자의 요청이 단순 정적인 파일 서빙으로 해결이 안 될 경우, 즉 사용자마다 서로 다른 페이지를 보여줘야 허거나 특정 비지니스 로직, 혹은 DB 와의 상호작용이 필요한 경우가 이에 해당된다.</p><p><img src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/fec035ee-2eab-4401-80a0-81dfeb3968c2"><center>출처 : <a href="https://dkswnkk.tistory.com/503?category=551275">https://dkswnkk.tistory.com/503?category=551275</a></center></p><p>&nbsp;</p><p><strong>WAS</strong>는 위 이미지와 같이 <strong>Web Server</strong>와 <strong>Web Container</strong>로 이루어져 있다. 다만 통상적인 개발 과정에서는 <strong>WAS</strong>와 <strong>Web Server</strong>를 분리하여 개발하는 경우가 잦다. 아래와 같은 구조를 의미한다.</p><p><img src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/178542e1-4112-48da-9b9b-e515acf2fafe"><center>출처 : <a href="https://dkswnkk.tistory.com/503?category=551275">https://dkswnkk.tistory.com/503?category=551275</a></center></p><p>&nbsp;</p><p>즉 1차적으로 사용자가 요청한 내용을 <strong>Web Server</strong>에서 처리한다. 해당 요청이 단순 정적인 파일 서빙으로 해결될 수 있는 문제의 경우 <strong>Web Server</strong>가 자체적으로 해당 파일을 서빙하여 해결한다. 다만 <strong>비즈니스 로직</strong>이나 <strong>DB 조회</strong>가 필요한 <strong>동적인 파일</strong>의 경우 <strong>WAS</strong>에 요청하여 해당 요청을 처리한다.</p><p>&nbsp;</p><p>이와 같은 구조로 구성할 경우 아래와 같은 장점을 얻을 수 있다.</p><h3 id="1-WAS-서버-부하-방지"><a href="#1-WAS-서버-부하-방지" class="headerlink" title="1. WAS 서버 부하 방지"></a>1. WAS 서버 부하 방지</h3><p><strong>WAS</strong> 서버는 실제 비즈니스 로직 및 DB 조회를 담당하는데, 단순 정적 파일 또한 WAS에서 서빙할 경우 다른 작업으로 인해 불필요한 딜레이가 발생할 수 있다.</p><h3 id="2-로직-분리를-통한-보안-강화"><a href="#2-로직-분리를-통한-보안-강화" class="headerlink" title="2. 로직 분리를 통한 보안 강화"></a>2. 로직 분리를 통한 보안 강화</h3><p>일반적인 사용자들은 <strong>Web Server</strong>에만 접근하고 <strong>WAS</strong>는 알 필요가 없다. 따라서 사용자들에게 노출되는 부분은 <strong>Web Server</strong>로 한정지어 불필요한 위험으로부터 분리하여 비즈니스 로직 등 중요 데이터들을 안전하게 지킬 수 있다.</p><h3 id="3-다수의-WAS-서버-연결"><a href="#3-다수의-WAS-서버-연결" class="headerlink" title="3. 다수의 WAS 서버 연결"></a>3. 다수의 WAS 서버 연결</h3><p>동일한 서비스를 제공하는 복수의 <strong>WAS</strong> 서버를 연결하여 특정 서버에 가해지는 부하를 줄일 수 있다 (<strong>Load Balancing</strong>). 또한 특정 한 서버가 다운 되더라도 여분의 서버를 통해 안정적인 서비스를 제공할 수 있다 (<strong>Fail Over</strong>)</p><h3 id="4-여러-웹-어플리케이션과의-연결"><a href="#4-여러-웹-어플리케이션과의-연결" class="headerlink" title="4. 여러 웹 어플리케이션과의 연결"></a>4. 여러 웹 어플리케이션과의 연결</h3><p>서로 다른 기능을 담당하는 <strong>WAS</strong>를 연결하여 복수의 서비스를 제공할 수 있다</p><p>&nbsp;<br>&nbsp;</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p><strong>Nginx</strong>(<strong>엔진엑스</strong>)란 <strong>Web Server</strong>의 일종으로, 현재 가장 상용화 된 방식 중 하나이다. 과거엔 <strong>Apahce</strong>(<strong>아파치</strong>)를 활용하여 <strong>Web Server</strong>를 구현하였는데, <strong>Apache</strong>는 쓰레드 방식으로 하나의 요청당 하나의 쓰레드가 새로 생성되어 해당 요청을 처리하는 방식이다. 이러한 방식의 경우 쓰레드를 생성하고 또 요청을 처리하기까지 많은 오버헤드가 발생하게 되어 사용에 꺼려지고 있다.</p><p><strong>Nginx</strong>는 이와 대조적으로 사전 정의된 설정값(*.conf)에 따라 <strong>Worker Process</strong>가 생성되고, 이 <strong>Worker Process</strong>가 일정 시간(<strong>keep alive</strong>)동안 유지되어 사용자의 요청(<strong>Connection</strong>)을 처리하는 방식이다. 이렇게 보면 <strong>Apache</strong>와 큰 차이가 없어 보이지만 가장 큰 핵심은 사용자의 요청을 비동기적으로 처리한다는 것이다. 사용자의 요청은 <strong>Queue</strong>에 대기상태로 쌓이고 유휴상태인 <strong>Worker Process</strong>가 해당 작업을 맡아 처리하는 방식이다. 이를 <strong>Event-Driven</strong> 방식이라 한다.</p><p><img src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/7a8a34ac-8c61-49af-ab95-fe9f0fef76a9"><center>출처 : <a href="https://whatisthenext.tistory.com/123">https://whatisthenext.tistory.com/123</a></center></p><p>&nbsp;</p><p>두 Web Server간의 성능 차이를 비교해보면 아래 이미지와 같다.</p><p><img src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/f91e3a66-deb9-461a-9194-5d542d10ff08"></p><center>Connection 수에 따른 메모리 사용량 비교</center><center>출처 : https://statuslist.app/nginx/variables/</center><p>&nbsp;</p><p><img src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/b6eefe31-9a4f-4f4d-a7e6-8979291ff960"></p><center>동시 요청된 Connection 수에 따른 처리 속도 비교</center><center>출처 : https://statuslist.app/nginx/variables/</center><p>&nbsp;<br>&nbsp;</p><h2 id="Nginx-to-WSGI"><a href="#Nginx-to-WSGI" class="headerlink" title="Nginx to WSGI"></a>Nginx to WSGI</h2><p><strong>WSGI</strong>(<strong>위스키</strong>)는 <strong>Web Server Gateway Interface</strong>의 약자로, <strong>Web Server</strong>와 <strong>Python</strong> 기반의 WAS를 연결해주기 위한 통신 규약이다. 일반적인 <strong>Apache</strong>, <strong>Nginx와</strong> 같은 <strong>Web Server</strong>는 <strong>Python</strong>을 모르기 때문에 <strong>Django</strong>(<strong>장고</strong>)나 <strong>Flask</strong>(<strong>플라스크</strong>) 기반으로 구현된 <strong>WAS</strong>에 요청을 보낼 수 없다. <strong>WSGI</strong>는 그 사이에서 이를 중계해주는 역할이다.</p><p>가장 일반적으로 <strong>Django</strong>는 <strong>Gunicorn</strong>(<strong>지유니콘</strong>)을 사용한다. 다만 <strong>Django</strong>를 경험해본 사람들은 <strong>Gunicorn</strong>을 사용하지 않고도 <strong>Django</strong> 기반 백엔드 서버에서 <strong>HTTP</strong> 통신을 정상적으로 이루었을 것이다. 이는 <code>python manage.py runserver</code> 명령어를 통해 <strong>WAS</strong>를 실행할 경우 기본적으로 <strong>Django</strong> 내장 <strong>WSGI</strong> 서버를 통해 사용자의 <strong>HTTP</strong> 요청을 처리하기 때문이다. 그럼에도 불구하고 장고 내장 <strong>WSGI</strong> 서버가 아닌 <strong>Guicorn</strong>이란 별도의 <strong>WSGI</strong> 서버를 통해 요청을 처리하는 이유는 아래와 같다.</p><blockquote><p>Gunicorn has many features that Django’s built-in server is lacking:</p><ul><li>gunicorn can spawn multiple worker processes to parallelize incoming requests to multiple CPU cores</li><li>gunicorn has better logging</li><li>gunicorn is generally optimized for speed</li><li>gunicorn can be configured to fine grades depending on your setup</li><li>gunicorn is actively designed and maintained with security in mind</li></ul><p>출처 : <a href="https://stackoverflow.com/questions/35657332/django-difference-between-using-server-through-manage-py-and-other-servers-like">https://stackoverflow.com/questions/35657332/django-difference-between-using-server-through-manage-py-and-other-servers-like</a></p></blockquote><p>&nbsp;<br>&nbsp;</p><h1 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h1><p>실습은 <strong>Docker-compose</strong>를 통해 <strong>Postgres</strong>, <strong>Django</strong>, <strong>Nginx</strong> 각각에 해당하는 <strong>Docker Container</strong>를 만들어 구성된 환경에서 진행되었다. 본 실습은 <strong>Docker-compose</strong>를 통해 각 <strong>Container</strong>간의 연결에 초점을 맞춘 관계로 <strong>Django</strong> 프로젝트 설정에 관한 내용은 생략하도록 하겠다. <code>local_settings.py</code>를 통해 <strong>DB</strong> 관련 설정을 해주었단 것만 주의하면 큰 문제는 없을 것이다. 프로젝트 디렉토리 구조는 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; tree</span></span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   ├── compose</span><br><span class="line">│   │   ├── django</span><br><span class="line">│   │   │   └── Dockerfile</span><br><span class="line">│   │   └── nginx</span><br><span class="line">│   │       └── nginx.conf</span><br><span class="line">│   ├── docker-compose.yml</span><br><span class="line">│   ├── requirements.txt</span><br><span class="line">│   └── restart_docker.sh</span><br><span class="line">└── practice</span><br><span class="line">    ├── manage.py</span><br><span class="line">    ├── practice</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── asgi.py</span><br><span class="line">    │   ├── local_settings.py</span><br><span class="line">    │   ├── settings.py</span><br><span class="line">    │   ├── urls.py</span><br><span class="line">    │   └── wsgi.py     <span class="comment"># Django 기본 WSGI 서버</span></span><br><span class="line">    └── practice_site</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        ├── admin.py</span><br><span class="line">        ├── apps.py</span><br><span class="line">        ├── fixtures</span><br><span class="line">        │   └── initial_data.json</span><br><span class="line">        ├── migrations</span><br><span class="line">        │   ├── 0001_initial.py</span><br><span class="line">        │   └── __init__.py</span><br><span class="line">        ├── models.py</span><br><span class="line">        ├── tests.py</span><br><span class="line">        ├── urls.py</span><br><span class="line">        └── views.py</span><br></pre></td></tr></table></figure><p><strong>Docker</strong> 컨테이너 구성을 위한 <strong>docker-compose.yml</strong> 파일은 아래와 같다.</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./bin/compose/docker-compose.yml</span></span><br><span class="line"></span><br><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  practice_database:    <span class="comment"># DB 서비스</span></span><br><span class="line">    container_name: practice_database</span><br><span class="line">    image: postgres:<span class="number">15</span></span><br><span class="line">    environment:</span><br><span class="line">      - POSTGRES_DB=practice</span><br><span class="line">      - POSTGRES_USER=practice</span><br><span class="line">      - POSTGRES_PASSWORD=practice</span><br><span class="line"></span><br><span class="line">  practice_web:    <span class="comment"># Django 서비스</span></span><br><span class="line">    container_name: practice_web</span><br><span class="line">    build:</span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: ./compose/django/Dockerfile    <span class="comment"># 별도의 Dokcerfile을 통해 빌드</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ..:/app    <span class="comment"># docker-compose 기준 상대참조하여 /app 디렉토리 내부로 마운트</span></span><br><span class="line">    working_dir: /app/practice</span><br><span class="line">    command: &gt;</span><br><span class="line">      sh -c <span class="string">&quot;</span></span><br><span class="line"><span class="string">        echo yes | python manage.py collectstatic &amp;&amp;    # static 파일을 빌드하기 위한 명령어</span></span><br><span class="line"><span class="string">        wait-for-it.sh practice_database:5432 &amp;&amp;    # DB 설정 완료까지 대기</span></span><br><span class="line"><span class="string">        python manage.py makemigrations &amp;&amp;</span></span><br><span class="line"><span class="string">        python manage.py migrate &amp;&amp;</span></span><br><span class="line"><span class="string">        python manage.py loaddata initial_data.json &amp;&amp;</span></span><br><span class="line"><span class="string">        gunicorn sweat.wsgi:application --workers=20 --timeout=300 --bind 0.0.0.0:8000</span></span><br><span class="line"><span class="string">      &quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - practice_database</span><br><span class="line"></span><br><span class="line">  practice_nginx:    <span class="comment"># Nginx 서비스</span></span><br><span class="line">    container_name: practice_nginx</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ../practice/static:/static    <span class="comment"># collectstatic 명령어를 통해 빌드된 파일을 마운트</span></span><br><span class="line">      - ./compose/nginx:/etc/nginx/conf.d    <span class="comment"># conf 설정 파일 마운트</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - practice_web</span><br></pre></td></tr></table></figure><p><strong>Docker-compose</strong> 구성에 사용된 <strong>Dockerfile</strong> 및 <strong>nginx.conf</strong>는 아래와 같다.</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bin/compose/django/Dockerfile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span>.<span class="number">6</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wait-for-it 스크립트를 통해 데이터베이스 설정 완료를 보장</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/wait-for-it.sh https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/wait-for-it.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 디렉토리 설정 및 필수 패키지 설치</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> requirements.txt /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --upgrade pip \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./bin/compose/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name practice_web;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_http_version <span class="number">1.1</span>;</span><br><span class="line">        proxy_pass http://practice_web:<span class="number">8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /static/ &#123;</span><br><span class="line">        alias /static/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Docker</strong> 재실행을 위한 스크립트 <strong>restart_docker.sh</strong>는 다음과 같다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./bin/compose/restart_docker.sh</span></span><br><span class="line"></span><br><span class="line">docker-compose -p practice down</span><br><span class="line">docker-compose -p practice up -d</span><br></pre></td></tr></table></figure><p>해당 스크립트를 통해 <strong>Docker</strong>를 재실행해보면 아래와 같은 결과를 <strong>Docker-Desktop</strong>에서 확인할 수 있다.</p><img width="1792" alt="image" src="https://github.com/bigpie1367/bigpie1367.github.io/assets/52846766/2f9cea91-6965-48b2-944e-949dd419bfb6"><p>&nbsp;<br>&nbsp;</p><h1 id="참고-문헌"><a href="#참고-문헌" class="headerlink" title="참고 문헌"></a>참고 문헌</h1><p><a href="%5Bhttps://dkswnkk.tistory.com/503?category=551275%5D(https://dkswnkk.tistory.com/503?category=551275)">Web Server와 WAS의 차이</a></p><p><a href="%5Bhttps://velog.io/@bluewind8791/WAS-vs-web-server%5D(https://velog.io/@bluewind8791/WAS-vs-web-server)">WAS vs 웹 서버</a></p><p><a href="%5Bhttps://velog.io/@gillog/Web-Server%EC%99%80-Web-Application-Server%EC%9D%98-%EC%B0%A8%EC%9D%B4%5D(https://velog.io/@gillog/Web-Server%EC%99%80-Web-Application-Server%EC%9D%98-%EC%B0%A8%EC%9D%B4)">Web Server와 Web Application Server</a></p><p><a href="%5Bhttps://velog.io/@leesomyoung/%EC%9B%B9-%EC%84%9C%EB%B2%84-vs-WAS%5D(https://velog.io/@leesomyoung/%EC%9B%B9-%EC%84%9C%EB%B2%84-vs-WAS)">웹 서버 vs WAS</a></p><p><a href="%5Bhttps://yozm.wishket.com/magazine/detail/1780/%5D(https://yozm.wishket.com/magazine/detail/1780/)">웹서버와 WAS(Web Application Server)</a></p><p><a href="%5Bhttps://help.dreamhost.com/hc/en-us/articles/215945987-Web-server-performance-comparison%5D(https://help.dreamhost.com/hc/en-us/articles/215945987-Web-server-performance-comparison)">Web server performance comparison</a></p><p><a href="%5Bhttps://wikidocs.net/75556%5D(https://wikidocs.net/75556)">WSGI 서버</a></p><p><a href="%5Bhttps://sgc109.github.io/2020/08/15/python-wsgi/%5D(https://sgc109.github.io/2020/08/15/python-wsgi/)">WSGI란?</a></p><p><a href="%5Bhttps://ssdragon.tistory.com/60%5D(https://ssdragon.tistory.com/60)">Nginx란?</a></p><p><a href="%5Bhttps://dkswnkk.tistory.com/513%5D(https://dkswnkk.tistory.com/513)">Nginx란 무엇인가?</a></p><p><a href="%5Bhttps://whatisthenext.tistory.com/123%5D(https://whatisthenext.tistory.com/123)">Nginx 이해하기 및 기본 환경 설정 세팅하기</a></p><p><a href="%5Bhttps://phsun102.tistory.com/45%5D(https://phsun102.tistory.com/45)">Nginx 설치 및 nginx.conf, default.conf 이해하기</a></p><p><a href="%5Bhttps://wikidocs.net/6601#static_root%5D(https://wikidocs.net/6601#static_root)">Nginix, Gunicorn 배포</a></p><p><a href="%5Bhttps://velog.io/@devkwon/Django-nginx-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0%5D(https://velog.io/@devkwon/Django-nginx-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0)">Django Nginx 연결하기</a></p><p><a href="%5Bhttps://ssungkang.tistory.com/entry/Django-%EC%9B%B9%EC%84%9C%EB%B2%84-Nginx-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0%5D(https://ssungkang.tistory.com/entry/Django-%EC%9B%B9%EC%84%9C%EB%B2%84-Nginx-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)">Django 웹서버, Nginx 사용하기</a></p><p><a href="%5Bhttps://leffept.tistory.com/331%5D(https://leffept.tistory.com/331)">Docker-compose로 Django 환경 구축하기</a></p><p><a href="%5Bhttps://americanoisice.tistory.com/226%5D(https://americanoisice.tistory.com/226)">Docker-compose로 Django, Nginx, Gunicorn 연결후 AWS 배포하기</a></p><p><a href="%5Bhttps://velog.io/@masterkorea01/Docker-Nginx-gunicorn-django%5D(https://velog.io/@masterkorea01/Docker-Nginx-gunicorn-django)">Docker + Nginx + gunicorn + django</a></p><p><a href="%5Bhttps://stackoverflow.com/questions/35657332/django-difference-between-using-server-through-manage-py-and-other-servers-like%5D(https://stackoverflow.com/questions/35657332/django-difference-between-using-server-through-manage-py-and-other-servers-like)">Django: Difference between using server through manage.py and other servers like gunicorn etc. Which is better?</a></p><p><a href="%5Bhttps://statuslist.app/nginx/variables/%5D(https://statuslist.app/nginx/variables/)">How to use NGINX variables + Reference List</a></p>]]></content:encoded>
      
      
      <category domain="https://bigpie1367.github.io/categories/Backend/">Backend</category>
      
      <category domain="https://bigpie1367.github.io/categories/Backend/Django/">Django</category>
      
      
      <category domain="https://bigpie1367.github.io/tags/Backend-Django-Web-Server-WAS-Nginx/">Backend, Django, Web Server, WAS, Nginx</category>
      
      
      <comments>https://bigpie1367.github.io/2024/01/05/Web-Server%EB%B6%80%ED%84%B0-Nginx%EA%B9%8C%EC%A7%80/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
